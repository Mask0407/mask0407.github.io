<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mask0407.github.io</id>
    <title>个人博客</title>
    <updated>2020-06-29T03:07:06.880Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mask0407.github.io"/>
    <link rel="self" href="https://mask0407.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://mask0407.github.io/images/avatar.png</logo>
    <icon>https://mask0407.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 个人博客</rights>
    <entry>
        <title type="html"><![CDATA[关于Springboot、SpringCloud以及SpringCloud-Alibaba Nacos依赖问题]]></title>
        <id>https://mask0407.github.io/springcloud07/</id>
        <link href="https://mask0407.github.io/springcloud07/">
        </link>
        <updated>2020-06-29T03:06:45.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#springboot%E5%92%8Cspringcloud%E5%A4%A7%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB">SpringBoot和SpringCloud大版本对应关系</a></li>
<li><a href="#alibaba%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">Alibaba组件版本关系</a></li>
<li><a href="#springboot-cloud-alibaba-%E6%AF%95%E4%B8%9A%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8">SpringBoot、Cloud、Alibaba 毕业版本依赖关系(推荐使用)</a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">依赖管理</a>
<ul>
<li><a href="#release-%E7%89%88%E6%9C%AC">RELEASE 版本</a></li>
</ul>
</li>
<li><a href="#alibaba%E7%BB%84%E4%BB%B6%E4%BE%9D%E8%B5%96%E5%9D%90%E6%A0%87%E7%A4%BA%E4%BE%8B">Alibaba组件依赖坐标示例</a></li>
</ul>
</li>
</ul>
(依赖关系)<br>
由于目前阿里的SpringCloud组件以及孵化成功，导致写项目导入pom依赖坐标时比较纠结，网上对版本的兼容介绍也变得五花八门。</p>
<h2 id="springboot和springcloud大版本对应关系">SpringBoot和SpringCloud大版本对应关系</h2>
<table>
<thead>
<tr>
<th>Spring Boot</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.2.x</td>
<td>Angel版本</td>
</tr>
<tr>
<td>1.3.x</td>
<td>Brixton版本</td>
</tr>
<tr>
<td>1.4.x stripes</td>
<td>Camden版本</td>
</tr>
<tr>
<td>1.5.x</td>
<td>Dalston版本、Edgware版本</td>
</tr>
<tr>
<td>2.0.x</td>
<td>Finchley版本</td>
</tr>
<tr>
<td>2.1.x</td>
<td>Greenwich.SR2</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="https://start.spring.io/actuator/info">详细介绍，建议火狐浏览器</a></li>
</ul>
<h2 id="alibaba组件版本关系">Alibaba组件版本关系</h2>
<table>
<thead>
<tr>
<th>Spring Cloud Alibaba Version</th>
<th>Sentinel Version</th>
<th>Nacos Version</th>
<th>RocketMQ Version</th>
<th>Dubbo Version</th>
<th>Seata Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>(毕业版本) 2.2.0.RELEASE</td>
<td>1.7.1</td>
<td>1.1.4</td>
<td>4.4.0</td>
<td>2.7.4.1</td>
<td>1.0.0</td>
</tr>
<tr>
<td>(毕业版本) 2.1.1.RELEASE or 2.0.1.RELEASE or 1.5.1.RELEASE</td>
<td>1.7.0</td>
<td>1.1.4</td>
<td>4.4.0</td>
<td>2.7.3</td>
<td>0.9.0</td>
</tr>
<tr>
<td>(毕业版本) 2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE</td>
<td>1.6.3</td>
<td>1.1.1</td>
<td>4.4.0</td>
<td>2.7.3</td>
<td>0.7.1</td>
</tr>
<tr>
<td>(孵化器版本) 0.9.0.RELEASE or 0.2.2.RELEASE or 0.1.2.RELEASE</td>
<td>1.5.2</td>
<td>1.0.0</td>
<td>4.4.0</td>
<td>2.7.1</td>
<td>0.4.2</td>
</tr>
<tr>
<td>(孵化器版本) 0.2.1.RELEASE or 0.1.1.RELEASE</td>
<td>1.4.0</td>
<td>0.6.2</td>
<td>4.3.1</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>(孵化器版本) 0.2.0.RELEASE or 0.1.0.RELEASE</td>
<td>1.3.0-GA</td>
<td>0.3.0</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<h2 id="springboot-cloud-alibaba-毕业版本依赖关系推荐使用">SpringBoot、Cloud、Alibaba 毕业版本依赖关系(推荐使用)</h2>
<table>
<thead>
<tr>
<th>Spring Cloud Version</th>
<th>Spring Cloud Alibaba Version</th>
<th>Spring Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring Cloud Hoxton</td>
<td>2.2.0.RELEASE</td>
<td>2.2.X.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Greenwich</td>
<td>2.1.1.RELEASE</td>
<td>2.1.X.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Finchley</td>
<td>2.0.1.RELEASE</td>
<td>2.0.X.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Edgware</td>
<td>1.5.1.RELEASE</td>
<td>1.5.X.RELEASE</td>
</tr>
</tbody>
</table>
<h2 id="依赖管理">依赖管理</h2>
<p>Spring Cloud Alibaba BOM 包含了它所使用的所有依赖的版本。</p>
<h3 id="release-版本">RELEASE 版本</h3>
<ul>
<li>Spring Cloud Hoxton<br>
如果需要使用 Spring Cloud Hoxton 版本，请在 dependencyManagement 中添加如下内容</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
```xml

- Spring Cloud Greenwich
如果需要使用 Spring Cloud Greenwich 版本，请在 dependencyManagement 中添加如下内容
```xml
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>Spring Cloud Finchley<br>
如果需要使用 Spring Cloud Finchley 版本，请在 dependencyManagement 中添加如下内容</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>Spring Cloud Edgware<br>
如果需要使用 Spring Cloud Edgware 版本，请在 dependencyManagement 中添加如下内容</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
    &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="alibaba组件依赖坐标示例">Alibaba组件依赖坐标示例</h2>
<p>以Nacos为例</p>
<pre><code class="language-xml">		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
		&lt;/dependency&gt;
</code></pre>
<p>摘自  <a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本说明</a><br>
更多孵化器版本对应可点击链接去官网查看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Feign开启HyStrix后如何配置线程隔离及熔断策略]]></title>
        <id>https://mask0407.github.io/springcloud06/</id>
        <link href="https://mask0407.github.io/springcloud06/">
        </link>
        <updated>2020-06-29T03:06:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Feign集成Hystrix默认是关闭Hystrix的，只有在配置文件中设置<code>feign.hystrix.enabled=true</code>才会开启Hystrix。</p>
</blockquote>
<p>开启Hystrix后feign之间的方法调用就会默认启动新的线程执行和主程序不在一个线程中，因此如果上下文中存在ThreadLocal变量，在该方法中就失效了。因此一般可以通过设置<code>CommandProperties</code>注解属性，设置线程就可以了。</p>
<p>在和Feign整合后，用户无法配置Feign的<code>ComandProperties</code>，但是可以通过配置Bean的形式配置。</p>
<pre><code class="language-java">@Configuration
public class FeignSupportConfig {
	@Bean
	public SetterFactory setterFactory(){
		SetterFactory setterFactory =new SetterFactory() {
			@Override
			public HystrixCommand.Setter create(Target&lt;?&gt; target, Method method) {

				String groupKey = target.name();
				String commandKey = Feign.configKey(target.type(), method);

				HystrixCommandProperties.Setter setter = HystrixCommandProperties.Setter()
						//设置统计指标60秒为一个时间窗口
						.withMetricsRollingStatisticalWindowInMilliseconds(1000 * 60)
						//超过80%失败率
						.withCircuitBreakerErrorThresholdPercentage(80)
						//操作5个开启短路器
						.withCircuitBreakerRequestVolumeThreshold(5)
						//设置线程隔离
						.withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)
						//设置断路器的开启时间为60秒
						.withCircuitBreakerSleepWindowInMilliseconds(1000 * 60);

				return HystrixCommand.Setter
						.withGroupKey(HystrixCommandGroupKey.Factory.asKey(groupKey))
						.andCommandKey(HystrixCommandKey.Factory.asKey(commandKey))
						.andCommandPropertiesDefaults(setter);
			}
		};
		return setterFactory;
	}

}
</code></pre>
<blockquote>
<p>然后在@FeignClient中引入该配置</p>
</blockquote>
<pre><code class="language-java">@FeignClient(name = &quot;USER-SERVICE&quot;, configuration = FeignSupportConfig.class) //name为服务名
</code></pre>
<p>至此，方法调用将会和主线程ID一直。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之配置中心-Config]]></title>
        <id>https://mask0407.github.io/springcloud05/</id>
        <link href="https://mask0407.github.io/springcloud05/">
        </link>
        <updated>2020-06-29T03:05:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="config-server">Config-Server</h2>
<p>Spring Cloud Config 是 Spring Cloud 团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持， 它分为服务端与客户端两个部分。服务端称为分布式配置中心， 它是一个独立的微服务应用， 用来连接配置仓库并为客户端提供获取配置信息、 加密／解密信息等访问接口；客户端微服务架构中的各个微服务应用或基础设施， 它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。<br>
<img src="https://img-blog.csdnimg.cn/20200323105501991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>Spring Cloud Config 实现了对服务端和客户端中环境变量和属性配置的抽象映射， 所以它除了适用于 Spring 构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。 由于 Spring Cloud Config 实现的配置中心默认采用 Git 来存储配置信息， 所以使用 Spring Cloud Config 构建的配置服务器，天然就支持对微服务应用配置信息的版本管理， 并且可以通过 Git 客户端工具来方便地管理和访问配置内容。 当然它也提供了对其他存储方式的支持， 比如 SVN 仓库、 本地化文件系统。</p>
</blockquote>
<h2 id="快速入门">快速入门</h2>
<h3 id="配置中心服务">配置中心服务</h3>
<ul>
<li>在码云(GITEE)新建配置文件（可选GitHub、GitLab）</li>
</ul>
<blockquote>
<p>在码云新建项目config-server，在新项目下新建配置文件夹config，在config下创建application-test.properties，配置文件命名规则应尽可能使用：{application}-{profile}.{properties|yml}</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200323112514215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li>config-server/config/application-test.properties</li>
</ul>
<pre><code class="language-properties">name=mask
age=18
</code></pre>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>项目中application.properties</li>
</ul>
<pre><code class="language-properties">server.port=8081
spring.cloud.config.server.git.uri=https://gitee.com/mask_0407/config-server.git
spring.cloud.config.server.git.username=****** #码云账号
spring.cloud.config.server.git.password=****** #码云密码
spring.cloud.config.server.git.search-paths=/config
</code></pre>
<ul>
<li>App.java</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigServer
public class App {
	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}
}
</code></pre>
<p>启动项目后访问：<a href="http://localhost:8081/application-test.properties">http://localhost:8081/application-test.properties</a><br>
<img src="https://img-blog.csdnimg.cn/20200323112829283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="config-client">Config-Client</h2>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">		&lt;!--config client依赖--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;!--ConfigurationProperties类所需依赖，手动添加的--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
			&lt;optional&gt;true&lt;/optional&gt;
		&lt;/dependency&gt;
</code></pre>
<ul>
<li>码云中application-test.properties</li>
</ul>
<pre><code class="language-properties">server.port = 8082
name=mask
age=18
</code></pre>
<ul>
<li>bootstrap.properties</li>
</ul>
<pre><code class="language-properties">server.port = 8082
spring.application.name = application #对应application-test.properties 中的application
spring.cloud.config.profile = test #对应application-test.properties 中的test
spring.cloud.config.uri=http://localhost:8081 # config-server 地址
# 开启所有的健康检查
management.endpoints.web.exposure.include=*
</code></pre>
<ul>
<li>AppClient</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
@RestController
public class AppClient {
	@Value(&quot;${server.port}&quot;)
	private String port;
	public static void main(String[] args) {
		SpringApplication.run(AppClient.class, args);
	}

	@RequestMapping(&quot;print&quot;)
	public String print() {
		return port;
	}
}
</code></pre>
<p>启动项目访问<a href="http://localhost:8082/print">http://localhost:8082/print</a><br>
<img src="https://img-blog.csdnimg.cn/2020032314384953.png" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之OpenFeign]]></title>
        <id>https://mask0407.github.io/springcloud04/</id>
        <link href="https://mask0407.github.io/springcloud04/">
        </link>
        <updated>2020-06-29T03:04:55.000Z</updated>
        <content type="html"><![CDATA[<p>Feign提供声明式的远程调用，借用动态代理实现远程调用，使编写Web服务客户端变得更容易。 Spring Cloud增加了对Spring MVC注释的支持，并使用了Spring Web中默认使用的相同HttpMessageConverters。 Spring Cloud集成了Ribbon和Eureka，在使用Feign时提供负载均衡的http客户端。</p>
<h2 id="快速入门">快速入门</h2>
<ul>
<li>Eureka-server配置</li>
</ul>
<pre><code class="language-properties">server.port=8088

eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
spring.security.user.name=mask
spring.security.user.password=111111
</code></pre>
<ul>
<li>Eureka-Server</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaApp{
	public static void main(String[] args) {
		SpringApplication.run(EurekaApp.class,args);
	}
}
</code></pre>
<ul>
<li>服务提供者A</li>
</ul>
<pre><code class="language-prperties">spring.application.name=USER-SERVICE
eureka.instance.instance-id=001
eureka.instance.prefer-ip-address=true
eureka.instance.lease-expiration-duration-in-seconds=20
eureka.instance.lease-renewal-interval-in-seconds=10

eureka.client.register-with-eureka=true
eureka.client.healthcheck.enabled=true
eureka.client.fetch-registry=false
eureka.client.service-url.defaultZone=http://mask:111111@localhost:8088/eureka/
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
@RestController
@RequestMapping(&quot;main&quot;)
public class EurekaApp {
	public static void main(String[] args) {
		SpringApplication.run(EurekaApp.class,args);
	}

	@RequestMapping(value = &quot;index&quot;, method = {RequestMethod.GET})
	public String index() {
		return &quot;服务A&quot;;
	}
}
</code></pre>
<ul>
<li>服务提供者B</li>
</ul>
<pre><code class="language-proeprties">server.port=8081
spring.application.name=USER-SERVICE
eureka.instance.instance-id=002
eureka.instance.prefer-ip-address=true
eureka.instance.lease-expiration-duration-in-seconds=20
eureka.instance.lease-renewal-interval-in-seconds=10

eureka.client.register-with-eureka=true
eureka.client.healthcheck.enabled=true
eureka.client.fetch-registry=false
eureka.client.service-url.defaultZone=http://mask:111111@localhost:8088/eureka/
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
@RestController
@RequestMapping(&quot;main&quot;)
public class EurekaApp {
	public static void main(String[] args) {
		SpringApplication.run(EurekaApp.class,args);
	}

	@RequestMapping(value = &quot;index&quot;, method = {RequestMethod.GET})
	public String index() {
		return &quot;服务B&quot;;
	}

}
</code></pre>
<ul>
<li>Eureka-Consumer<br>
新增依赖</li>
</ul>
<pre><code class="language-xml">		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
		&lt;/dependency&gt;
</code></pre>
<p>创建接口 UserServiceController</p>
<pre><code class="language-java">@FeignClient(name = &quot;USER-SERVICE&quot;) //name为服务名
public interface UserServiceController {
	@GetMapping(&quot;main/index&quot;) //该方法映射的路径
	String index();
}
</code></pre>
<pre><code class="language-properties">server.port=8089
ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule
eureka.client.fetch-registry=true
eureka.client.register-with-eureka=false
eureka.client.service-url.defaultZone=http://mask:111111@localhost:8088/eureka/
</code></pre>
<pre><code class="language-java">@SpringBootApplication
@RestController
@EnableFeignClients
public class EurekaSpringBootConsumer {
	public static void main(String[] args) {
		SpringApplication.run(EurekaSpringBootConsumer.class,args);
	}
	@Autowired
	private UserServiceController userServiceController;

	@GetMapping(&quot;/rpc/test&quot;)
	public String index() {
		String index = userServiceController.index();
		System.out.println(index);
		return &quot;OK&quot;;
	}

}
</code></pre>
<blockquote>
<p>访问<a href="http://localhost:8089/rpc/test">http://localhost:8089/rpc/test</a><br>
底层会根据接口方法的配置信息参数发送请求给远程的服务器这种实现比单纯的使用Ribbon更加的优雅。实际上Feign底层就是对Ribbon组件的封装。</p>
</blockquote>
<p>注：在Fegin里不能传递自定义类型至GET查询参数</p>
<h2 id="feigen-熔断">Feigen 熔断</h2>
<p>默认Feign没有开启熔断策略，需要用户在配置文件中指定</p>
<ul>
<li>EurekaConsumer中新增配置</li>
</ul>
<pre><code class="language-properties">feign.hystrix.enabled=true
</code></pre>
<ul>
<li>修改UserServiceController</li>
</ul>
<pre><code class="language-java">@FeignClient(name = &quot;USER-SERVICE&quot;, fallback = UserServiceFailBack.class) //name为服务名
public interface UserServiceController {
	@GetMapping(&quot;main/index&quot;) //该方法映射的路径
	String index();
}
</code></pre>
<ul>
<li>新增UserServiceFailBack类</li>
</ul>
<pre><code>@Component
public class UserServiceFailBack implements UserServiceController{
	@Override
	public String index() {
		return &quot;熔断&quot;;
	}
}
</code></pre>
<ul>
<li>修改服务B使其抛出异常</li>
</ul>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;main&quot;)
public class TestController {
	@RequestMapping(value = &quot;index&quot;, method = {RequestMethod.GET})
	public String index() {
		int i = 1/0;
		return &quot;服务B&quot;;
	}
}
</code></pre>
<p>启动服务多次访问<a href="http://localhost:8089/rpc/test">http://localhost:8089/rpc/test</a>如下图可看出服务B抛出异常后执行熔断后代码<br>
<img src="https://img-blog.csdnimg.cn/20200226220715601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="feign超时设置">Feign超时设置</h2>
<pre><code class="language-prperties">feign.client.config.USER-SERVICE.connect-timeout=500
feign.client.config.USER-SERVICE.read-timeout=500
</code></pre>
<h2 id="hystrix-dashboard">Hystrix Dashboard</h2>
<ul>
<li>pom引入</li>
</ul>
<pre><code class="language-xml">	&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<ul>
<li>application.properties新增</li>
</ul>
<pre><code class="language-propertis">management.endpoints.web.exposure.include=*
</code></pre>
<ul>
<li>启动类新增注解</li>
</ul>
<pre><code class="language-java">@EnableHystrixDashboard
@EnableCircuitBreaker
</code></pre>
<h2 id="配置hystrix属性">配置HyStrix属性</h2>
<p><a href="https://blog.csdn.net/M283592338/article/details/105133548">在和Feign整合后，用户无法配置Feign的ComandProperties，但是可以通过配置Bean的形式配置</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之服务注册-Eureka]]></title>
        <id>https://mask0407.github.io/springcloud03/</id>
        <link href="https://mask0407.github.io/springcloud03/">
        </link>
        <updated>2020-06-29T03:04:10.000Z</updated>
        <content type="html"><![CDATA[<p>Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分， 它基于 Netflix Eureka 做了二次封装， 主要负责完成微服务架构中的服务治理功能。 Spring Cloud 通过为Eureka 增加了 Spring Boot 风格的自动化配置，我们只需通过简单引入依赖和注解配置就能让 Spring Boot构建的微服务应用轻松地与 Eureka 服务治理体系进行整合。<br>
<img src="https://img-blog.csdnimg.cn/20200214185404109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="eureka单机">Eureka单机</h2>
<ul>
<li>依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>applicaiton.properties</li>
</ul>
<pre><code class="language-properties">server.port=8088

eureka.instance.hostname=localhost
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
</code></pre>
<blockquote>
<p>必须配置<code>eureka.instance.hostname</code>否则Eureka会尝试自我注册</p>
</blockquote>
<ul>
<li>EurekaSpringBootApplication</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class EurekaSpringBootApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaSpringBootApplication.class,args);
    }
}
</code></pre>
<ul>
<li>启动项目后访问 <a href="http://localhost:8088/">http://localhost:8088/</a><br>
<img src="https://img-blog.csdnimg.cn/20200214191748549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></li>
<li>配置说明</li>
</ul>
<table>
<thead>
<tr>
<th>配置</th>
<th>说明</th>
<th>默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>eureka.server.enable-self-preservation</td>
<td>Eureka自我保护机制</td>
<td>true</td>
</tr>
<tr>
<td>eureka.server.eviction-interval-timer-in-ms	Eureka</td>
<td>剔除故障节点时间间隔</td>
<td>60秒</td>
</tr>
<tr>
<td>eureka.server.renewal-percent-threshold</td>
<td>Eureka租约计算阈值</td>
<td>0.85</td>
</tr>
<tr>
<td>eureka.client.register-with-eureka</td>
<td>是否注册到Eureka上</td>
<td>true</td>
</tr>
<tr>
<td>eureka.client.fetch-registry</td>
<td>是否从Eureka上更新列表信息</td>
<td>true</td>
</tr>
<tr>
<td>eureka.instance.hostname</td>
<td>Eureka微服务实例的主机名</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="服务注册">服务注册</h2>
<ul>
<li>依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>application.properties</li>
</ul>
<pre><code class="language-properties">spring.application.name=USER-SERVICE
eureka.instance.instance-id=001
eureka.instance.prefer-ip-address=true
eureka.instance.lease-expiration-duration-in-seconds=20
eureka.instance.lease-renewal-interval-in-seconds=10

eureka.client.register-with-eureka=true
eureka.client.healthcheck.enabled=true
eureka.client.fetch-registry=false
eureka.client.service-url.defaultZone=http://localhost:8088/eureka/
</code></pre>
<blockquote>
<p>运行项目实现服务的注册</p>
</blockquote>
<ul>
<li>注册两个服务后<br>
<img src="https://img-blog.csdnimg.cn/20200218101430947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<h2 id="引入依赖">引入依赖</h2>
<blockquote>
<p>Eureka中默认集成了Ribbon插件，因此只需导入<code>spring-cloud-starter-netflix-eureka-client</code>即可。</p>
</blockquote>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;parent&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
  &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
      &lt;version&gt;Greenwich.SR1&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;

  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;

  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
  &lt;/dependency&gt;

  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<ul>
<li>application.properties</li>
</ul>
<pre><code class="language-properties">eureka.client.fetch-registry=true
eureka.client.register-with-eureka=false
eureka.client.service-url.defaultZone=http://localhost:8088/eureka/
</code></pre>
<ul>
<li>EurekaSpringBootConsumer</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
public class EurekaSpringBootConsumer {
    public static void main(String[] args) {
        SpringApplication.run(EurekaSpringBootConsumer.class,args);
    }
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
       return new RestTemplate();
    }
}
</code></pre>
<ul>
<li>RestTemplateTests</li>
</ul>
<pre><code class="language-java">@SpringBootTest(classes = EurekaSpringBootConsumer.class)
@RunWith(SpringRunner.class)
public class RestTemplateTests {
    @Autowired
    private RestTemplate restTemplate;
    @Test
    public void testQueryUserById(){
        String url=&quot;http://USER-SERVICE/manager/user/8&quot;;
        User user = restTemplate.getForObject(url, User.class);
        System.out.println(user);
    }
}
</code></pre>
<h2 id="eureka-server安全">Eureka Server安全</h2>
<ul>
<li>新增依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>新增配置</li>
</ul>
<pre><code class="language-properties">spring.security.user.name=mask
spring.security.user.password=111111
</code></pre>
<ul>
<li>新增配置类 WebSecurityConfig</li>
</ul>
<pre><code class="language-java">@EnableWebSecurity
@Configuration
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.csrf().disable(); // 关闭csrf,否则其他主机无法登陆认证
    http.authorizeRequests().anyRequest().authenticated().and().httpBasic();//设置成httpBasic，不可以设置为表单
  }

}
</code></pre>
<ul>
<li>服务 注册/消费 新增配置</li>
</ul>
<pre><code class="language-properties">eureka.client.service-url.defaultZone=http://mask:111111@localhost:8088/eureka/
</code></pre>
<h2 id="eureka服务端高可用配置">Eureka服务端高可用配置</h2>
<ul>
<li>application-eureka-1.properties</li>
</ul>
<pre><code class="language-properties">server.port=6666

## 指定当前注册中心的服务名称
spring.application.name=eurekaregistry

## 启用注册中心主动失效，并且每次主动失效检测间隔为5s 默认值60s
eureka.server.eviction-interval-timer-in-ms= 5000
## 设置eureka注册中心的响应更新时间
eureka.server.responseCacheUpdateIntervalMs=3000
eureka.server.responseCacheAutoExpirationInSeconds=60

## 配置注册中心的主机名
eureka.instance.instance-id = eureka-1
eureka.instance.hostname = CentOSA
## 服务刷新时间配置，每隔这个时间会主动心跳一次
eureka.instance.lease-renewal-interval-in-seconds= 5
## 服务提供者被认定为丢失心跳超时，失效多久后被删除
eureka.instance.lease-expiration-duration-in-seconds=15

## 配置定时获取|抓取注册中心的数据时间
eureka.client.registry-fetch-interval-seconds= 5
eureka.client.instance-info-replication-interval-seconds= 5
## 配置集群中其他eureka实例，用于本eureka实例的注册方。
eureka.client.region=beijing
eureka.client.availability-zones.beijing=zone-2,zone-3
eureka.client.service-url.zone-2=http://mask:111111@CentOSB:1111/eureka/
eureka.client.service-url.zone-3=http://mask:111111@CentOSC:1111/eureka/

spring.security.user.name=mask
spring.security.user.password=111111
</code></pre>
<ul>
<li>application-eureka-2.properties</li>
</ul>
<pre><code class="language-properties">server.port=6666

## 指定当前注册中心的服务名称
spring.application.name=eurekaregistry

## 启用注册中心主动失效，并且每次主动失效检测间隔为5s 默认值60s
eureka.server.eviction-interval-timer-in-ms= 5000
## 设置eureka注册中心的响应更新时间
eureka.server.responseCacheUpdateIntervalMs=3000
eureka.server.responseCacheAutoExpirationInSeconds=60

## 配置注册中心的主机名
eureka.instance.instance-id = eureka-2
eureka.instance.hostname = CentOSB
## 服务刷新时间配置，每隔这个时间会主动心跳一次
eureka.instance.lease-renewal-interval-in-seconds= 5
## 服务提供者被认定为丢失心跳超时，失效多久后被删除
eureka.instance.lease-expiration-duration-in-seconds=15

## 配置定时获取|抓取注册中心的数据时间
eureka.client.registry-fetch-interval-seconds= 5
eureka.client.instance-info-replication-interval-seconds= 5
## 配置集群中其他eureka实例，用于本eureka实例的注册方。
eureka.client.region=beijing
eureka.client.availability-zones.beijing=zone-1,zone-3
eureka.client.service-url.zone-1=http://mask:111111@CentOSA:1111/eureka/
eureka.client.service-url.zone-3=http://mask:111111@CentOSC:1111/eureka/

spring.security.user.name=mask
spring.security.user.password=111111
</code></pre>
<ul>
<li>application-eureka-3.properties</li>
</ul>
<pre><code class="language-properties">server.port=6666

## 指定当前注册中心的服务名称
spring.application.name=eurekaregistry

## 启用注册中心主动失效，并且每次主动失效检测间隔为5s 默认值60s
eureka.server.eviction-interval-timer-in-ms= 5000
## 设置eureka注册中心的响应更新时间
eureka.server.responseCacheUpdateIntervalMs=3000
eureka.server.responseCacheAutoExpirationInSeconds=60

## 配置注册中心的主机名
eureka.instance.instance-id = eureka-3
eureka.instance.hostname = CentOSC
## 服务刷新时间配置，每隔这个时间会主动心跳一次
eureka.instance.lease-renewal-interval-in-seconds= 5
## 服务提供者被认定为丢失心跳超时，失效多久后被删除
eureka.instance.lease-expiration-duration-in-seconds=15

## 配置定时获取|抓取注册中心的数据时间
eureka.client.registry-fetch-interval-seconds= 5
eureka.client.instance-info-replication-interval-seconds= 5
## 配置集群中其他eureka实例，用于本eureka实例的注册方。
eureka.client.region=beijing
eureka.client.availability-zones.beijing=zone-1,zone-2
eureka.client.service-url.zone-1=http://mask:111111@CentOSA:1111/eureka/
eureka.client.service-url.zone-2=http://mask:111111@CentOSB:1111/eureka/

spring.security.user.name=mask
spring.security.user.password=111111
</code></pre>
<ul>
<li>将三个项目打包分别上传至CentOSA、CentOSB、CentOSC运行</li>
</ul>
<blockquote>
<p>注：三台机器需关闭防火墙并互相做主机名与IP映射</p>
</blockquote>
<ul>
<li>访问<a href="http://CentOSA:6666/">http://CentOSA:6666/</a>  ---CentOSA可换为ip<br>
<img src="https://img-blog.csdnimg.cn/2020022120374450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之熔断器-Hystrix]]></title>
        <id>https://mask0407.github.io/springcloud02/</id>
        <link href="https://mask0407.github.io/springcloud02/">
        </link>
        <updated>2020-06-29T03:02:51.000Z</updated>
        <content type="html"><![CDATA[<p>Hystrix是一个延迟和容错库，旨在隔离对远程系统，服务和第三方库的访问点，停止级联故障，并在复杂的分布式系统中实现弹性，在这些系统中，故障是不可避免的。<br>
<img src="https://img-blog.csdnimg.cn/20200213161905569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="依赖">依赖</h2>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>SpringBootApplication入口中需要添加<code>@EnableCircuitBreaker</code>注解，此时Spring工厂会启动AOP方式对所有的方法上有<code>@HystrixCommand</code>的业务方法添加熔断策略。</p>
<pre><code class="language-java">@SpringBootApplication
@EnableCircuitBreaker
public class HystrixSpringBootApplication {
    public static void main(String[] args) {
        SpringApplication.run(HystrixSpringBootApplication.class,args);
    }
}
</code></pre>
<p>在业务方法上添加<code>@HystrixCommand</code>注解实现熔断。</p>
<pre><code class="language-java">@HystrixCommand
@Override
public User queryUserById(Integer id) {
    System.out.println(Thread.currentThread().getId());
    return new User(&quot;未熔断&quot;, new Date(), true, 11.11);
}
</code></pre>
<h2 id="线程隔离">线程隔离</h2>
<p>默认该方法的执行会启动新的线程执行和主程序不在一个线程中，因此如果上下文中存在ThreadLocal变量，在该方法中就失效了。因此一般可以通过设置commandProperties注解属性，设置线程就可以了。</p>
<ul>
<li>默认情况Service和Controller线程ID<br>
<img src="https://img-blog.csdnimg.cn/20200213165302950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<pre><code class="language-java">@HystrixCommand(commandProperties = {
            @HystrixProperty(name = &quot;execution.isolation.strategy&quot;,value = &quot;SEMAPHORE&quot;)
    })
@Override
public User queryUserById(Integer id) {
	System.out.println(&quot;Service线程ID:&quot; + Thread.currentThread().getId());
    return new User(&quot;未熔断&quot;, new Date(), true, 11.11);
}
</code></pre>
<ul>
<li>设置后Service和Controller线程ID<br>
<img src="https://img-blog.csdnimg.cn/20200213165644697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<blockquote>
<p><code>execution.isolation.strategy</code>该属性的可选值有两个<code>THREAD</code>和<code>SEMAPHORE</code>默认值是<code>THREAD</code>。①一般如果一个实例一秒钟有100个并发，此时因为频繁启动线程的开销过大此时一般考虑使用SEMAPHORE，②非网络调用。</p>
</blockquote>
<h2 id="fallback">Fallback</h2>
<p>过在<code>@HystrixCommand中声明fallbackMethod</code>的名称可以实现优雅降级，如下所示：</p>
<pre><code class="language-java">@HystrixCommand(fallbackMethod = &quot;fallbackMethodQueryUserById&quot;)
@Override
public User queryUserById(Integer id) {
    System.out.println(Thread.currentThread().getId());
    int i=10/0;
    return new User(&quot;未熔断&quot;, new Date(), true, 11.11);
}
public User fallbackMethodQueryUserById(Integer id, Throwable e) {
    System.out.println(e.getMessage());
    return new User(&quot;熔断降级后&quot;, new Date(), true, 11.11);
}
</code></pre>
<p>调用结果：<br>
<img src="https://img-blog.csdnimg.cn/20200213170232834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>注意要求fallbackMethod方法和目标方法必须在同一个类中，具有相同的参数（异常参数可选）</p>
</blockquote>
<h2 id="error-propagation">Error Propagation</h2>
<p>根据此描述，<code>@ HystrixCommand</code>能够指定应忽略的异常类型。如下所述<code>ArithmeticException: / by zero</code>将不会触发fallbackMethod方法。</p>
<pre><code class="language-java">//	@HystrixCommand(fallbackMethod = &quot;fallbackMethodQueryUserById&quot;)
//	@HystrixCommand(commandProperties = {
//			@HystrixProperty(name = &quot;execution.isolation.strategy&quot;, value = &quot;SEMAPHORE&quot;)
//	})
	@HystrixCommand(fallbackMethod = &quot;fallbackMethodQueryUserById&quot;,ignoreExceptions = {ArithmeticException.class})
	@Override
	public User getUser(Integer id) {
		System.out.println(&quot;Service线程ID:&quot; + Thread.currentThread().getId());
		int i = 10 / 0;
		return new User(&quot;未熔断&quot;, new Date(), true, 11.11);
	}

	public User fallbackMethodQueryUserById(Integer id, Throwable e) {
		System.out.println(e.getMessage());
		return new User(&quot;熔断降级后&quot;, new Date(), true, 11.11);
	}
</code></pre>
<h2 id="请求超时熔断">请求超时熔断</h2>
<p>用户可以通过设置<code>execution.isolation.thread.timeoutInMilliseconds</code>属性设置一个方法最大请求延迟，系统会抛出<code>HystrixTimeoutException</code></p>
<pre><code class="language-java">@HystrixCommand(fallbackMethod = &quot;fallbackMethodQueryUserById&quot;,commandProperties = {
			@HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;100&quot;)
	})
	@Override
	public User getUser(Integer id) {
		System.out.println(&quot;Service线程ID:&quot; + Thread.currentThread().getId());
		try {
			Thread.sleep(500);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
//		int i = 10 / 0;
		return new User(&quot;未熔断&quot;, new Date(), true, 11.11);
	}

	public User fallbackMethodQueryUserById(Integer id, Throwable e) {
		System.out.println(e.getMessage());
		return new User(&quot;超时熔断&quot;, new Date(), true, 11.11);
	}
</code></pre>
<p>执行结果：<br>
<img src="https://img-blog.csdnimg.cn/20200213171122722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p><a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica</a><br>
<a href="https://github.com/Netflix/Hystrix/wiki/Configuration">https://github.com/Netflix/Hystrix/wiki/Configuration</a></p>
</blockquote>
<h2 id="hystrix-dashboard">Hystrix Dashboard</h2>
<h3 id="依赖-2">依赖</h3>
<pre><code class="language-xml"> &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
 &lt;/dependency&gt;
</code></pre>
<blockquote>
<p>SpringBoot入口类添加<code>@EnableHystrixDashboard</code>注解<br>
访问页面http://localhost:端口/hystrix</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200213172042298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之注册中心-Nacos]]></title>
        <id>https://mask0407.github.io/springcloud01/</id>
        <link href="https://mask0407.github.io/springcloud01/">
        </link>
        <updated>2020-06-29T03:02:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="nacos简介">Nacos简介</h1>
<p>Nacos是阿里巴巴开源的一款支持服务注册与发现，配置管理以及微服务管理的组件。用来取代以前常用的注册中心（zookeeper , eureka等等），以及配置中心（spring cloud config等等）。Nacos是集成了注册中心和配置中心的功能，做到了二合一。<br>
 Nacos gitHub : <a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a><br>
 Nocos 文档 ：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p>
<p>Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理，如：</p>
<ul>
<li>Kubernetes Service</li>
<li>gRPC &amp; Dubbo RPC Service</li>
<li>Spring Cloud RESTful Service</li>
</ul>
<h1 id="nacos安装">Nacos安装</h1>
<ul>
<li>下载<br>
GitHub下载失败或速度过慢可以去 <a href="https://gitee.com/">码云</a> 搜索Nacos<br>
<code>以码云为例（1.1.4版本）</code><br>
<img src="https://img-blog.csdnimg.cn/20200212210201615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
<li>安装并启动服务</li>
</ul>
<pre><code class="language-shell"># 下载完毕后解压至本地
cd nacos/
# maven编译
mvn -Prelease-nacos clean install -U
# 编译完成后启动服务
cd distribution/target/nacos/bin

#Linux/Mac环境执行
sh startup.sh -m standalone
# Windows环境执行
cmd startup.cmd
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200212211451786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
启动后查看日志</p>
<pre><code class="language-shell">cd ../logs
tail -f start.out
</code></pre>
<p>Nacos端口默认为8848<br>
访问地址：<a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之Ribbon-负载均衡]]></title>
        <id>https://mask0407.github.io/springcloud00/</id>
        <link href="https://mask0407.github.io/springcloud00/">
        </link>
        <updated>2020-06-29T03:00:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="负载均衡spring-cloud-ribbon">负载均衡:Spring Cloud Ribbon</h2>
<p>Spring Cloud Ribbon 是一个基于Http和TCP的客服端负载均衡工具，它是基于Netflix Ribbon实现的。通过SpringCloud的自动配置使得项目可以自动的给RestTemplate添加拦截器，实现负载均衡的作用。</p>
<h2 id="快速入门">快速入门</h2>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.mask&lt;/groupId&gt;
  &lt;artifactId&gt;cloud&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
  &lt;/properties&gt;


  &lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;
  &lt;/parent&gt;

  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
        &lt;version&gt;Greenwich.SR1&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
        &lt;scope&gt;import&lt;/scope&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;

  &lt;dependencies&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>application.properties</li>
</ul>
<pre><code class="language-properties">server.port=8080
#server.port=8088
USER-SERVICE.ribbon.listOfServers=localhost:8080,localhost:8088
USER-SERVICE.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule
</code></pre>
<ul>
<li>UserController</li>
</ul>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;manager&quot;)
public class UserController {
	@RequestMapping(value=&quot;user/{id}&quot;,method = {RequestMethod.GET})
	public User queyUserById(@PathVariable(value = &quot;id&quot;) Integer id){
		System.out.println(&quot;-------getUser--------&quot;);
		return new User(&quot;张三&quot;, new Date(), true, 12345.00);
	}

	@RequestMapping(value=&quot;user&quot;,method = {RequestMethod.POST})
	public User saveUser(@RequestBody User user){
		System.out.println(&quot;-------saveUser--------&quot;);
		return user;
	}

	@RequestMapping(value=&quot;user&quot;,method = {RequestMethod.PUT})
	public void update(@RequestBody User user){
		System.out.println(&quot;-------updateUser--------&quot;);
	}

	@RequestMapping(value=&quot;user/{pageNow}/{pageSize}&quot;,method = {RequestMethod.GET})
	public List&lt;User&gt; queyUserByPage(@PathVariable(value = &quot;pageNow&quot;) Integer pageNow,
									 @PathVariable(value = &quot;pageSize&quot;) Integer pageSize){
		List&lt;User&gt; list = new ArrayList&lt;&gt;();
		list.add(new User(&quot;张三&quot;, new Date(), false, 11111.00));
		list.add(new User(&quot;李四&quot;, new Date(), true, 20000.00));
		System.out.println(&quot;-------getUserPage--------&quot;);
		return list;
	}

	@RequestMapping(value=&quot;user/{ids}&quot;,method = {RequestMethod.DELETE})
	public void deleteUserById(@PathVariable(value = &quot;ids&quot;) Integer[] ids){
		System.out.println(&quot;-------deleteUsers--------&quot;);
	}
}
</code></pre>
<ul>
<li>SpringRibbonApplication</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
public class SpringRibbonApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringRibbonApplication.class,args);
    }
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre>
<ul>
<li>User</li>
</ul>
<pre><code class="language-java">public class User implements Serializable {
    private Integer id;
    private String name;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date birthDay;
    private Boolean sex;
    private Double salary;
}
</code></pre>
<ul>
<li>RestTemplateTests</li>
</ul>
<pre><code class="language-java">@SpringBootTest(classes = SpringRibbonApplication.class)
@RunWith(SpringRunner.class)
public class RestTemplateTests {
	@Autowired
	private RestTemplate restTemplate;
	@Test
	public void testQueryUserById(){
		String url=&quot;http://USER-SERVICE/manager/user/1&quot;;
		User user = restTemplate.getForObject(url, User.class);
		System.out.println(user);
	}
	@Test
	public void testQueryUserByPage(){
		String url=&quot;http://USER-SERVICE/manager/user/1/10&quot;;
		List&lt;User&gt; users = restTemplate.getForObject(url, List.class);
		for (int i = 0; i &lt; users.size(); i++) {
			System.out.println(users.get(i));
		}
	}
	@Test
	public void testSaveUser(){
		String url=&quot;http://USER-SERVICE/manager/user&quot;;
		User user = restTemplate.postForObject(url, new User(&quot;李四&quot;, new Date(), true, 15000.0), User.class);
		System.out.println(user);
	}
	@Test
	public void testUpdateUser(){
		String url=&quot;http://USER-SERVICE/manager/user&quot;;
		User user = new User(&quot;李四&quot;, new Date(), true, 18000.0);
		user.setId(3);
		restTemplate.put(url,user);
	}
	@Test
	public void testDeleteUser(){
		String url=&quot;http://USER-SERVICE/manager/user/1,2,3&quot;;
		restTemplate.delete(url);
	}
}
</code></pre>
<p>除此自外，SpringCloud提供了一种基于配置文件的配置方式</p>
<ul>
<li>SpringRibbonApplication</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@RibbonClient(name = &quot;USER-SERVICE&quot;,configuration = {UserSerivceRibbonConfigure.class})
public class SpringRibbonApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringRibbonApplication.class,args);
    }
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre>
<ul>
<li>UserSerivceRibbonConfigure</li>
</ul>
<pre><code class="language-java">@Configuration
public class UserSerivceRibbonConfigure {
    @Bean
    public ServerList&lt;Server&gt; ribbonServerList(){
        Server server1 = new Server(&quot;localhost&quot;, 8080);
        server1.setZone(&quot;beijing&quot;);

        Server server2 = new Server(&quot;localhost&quot;, 9090);
        server2.setZone(&quot;shanghai&quot;);
        return new StaticServerList&lt;Server&gt;(server1,server2);
    }

    @Bean
    public IRule ribbonRule(){
        return new RandomRule();
    }
    @Bean
    public ZonePreferenceServerListFilter ribbonServerListFilter(){
        ZonePreferenceServerListFilter filter = new ZonePreferenceServerListFilter();
        filter.setZone(&quot;beijing&quot;);
        return filter;
    }
}
</code></pre>
<p>用户可以直接使用LoadBalancerClient查询服务列表</p>
<pre><code class="language-java">@Autowired
private LoadBalancerClient loadBalancer;

@Test
public void testChoose(){
  for (Integer i=0;i&lt;10;i++){
    ServiceInstance instance = loadBalancer.choose(&quot;stores&quot;);
    URI storesUri = URI.create(String.format(&quot;http://%s:%s&quot;, instance.getHost(), instance.getPort()));
    System.out.println(storesUri);
  }
}
</code></pre>
<p>测试结果<br>
<img src="https://img-blog.csdnimg.cn/20200212152220673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200212152253747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Elasticsearch入门篇]]></title>
        <id>https://mask0407.github.io/elasticsearch00/</id>
        <link href="https://mask0407.github.io/elasticsearch00/">
        </link>
        <updated>2020-06-29T02:59:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="elasticsearch">ElasticSearch</h2>
<p>ElasticSearch:简称为ES，基于Lucene全文检索引擎服务，支持分布式集群（数据横向扩展、分布式计算）<br>
应用场景：1. 全文检索或者搜索服务	2. NOSQL数据库(ES中的数据单元为JSON)	3. ELK数据分析平台</p>
<p>NRT (near real time) 接近实时 ES中的一条数据写入后大概会有1s的延迟才能被检索到<br>
9300端口:Es节点之间通讯使用		9200:Es节点和外部通讯使用</p>
<p><strong>Es概念介绍</strong>:</p>
<table>
<thead>
<tr>
<th>名词</th>
<th>说明</th>
<th>额外补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引(index)</td>
<td>类似于数据库中的database</td>
<td></td>
</tr>
<tr>
<td>类型(type)</td>
<td>相当于sql中的table</td>
<td>Es6.0以后删除了类型的概念,6.0还可以设置类型,但只能设置一个</td>
</tr>
<tr>
<td>文档(Document)</td>
<td>相当于sql中的一行记录</td>
<td></td>
</tr>
<tr>
<td>分片(Shard)</td>
<td>每个索引都有1到多个分片, 每个分片都是一个luncene索引</td>
<td>片的好处: 分摊索引的搜索压力, 分片还支持水平的拓展和拆分以及分布式的操作, 可以提高搜索和其他处理的效率</td>
</tr>
<tr>
<td>备份/复制(replicas)</td>
<td>拷贝一个分片就完成了分片的备份</td>
<td>备份的好处: 当主分片失败或者挂掉, 备份就可以代替分片进行操作, 进而提高了es的可用性, 备份的分片还可以进行搜索操作, 以分摊搜索的压力.</td>
</tr>
<tr>
<td>映射(Mapping)</td>
<td>类似于Table的Schema(模式)</td>
<td>例如:create table person_info(name varchar(20),age tinyint)创建一张表,person后的括号是定义表中的字段,即为Schema</td>
</tr>
</tbody>
</table>
<p><strong>analyzer（分析器）介绍</strong><br>
analyzer（分析器）是一个包，这个包由三部分组成，分别是：character filters （字符过滤器）、tokenizer（分词器）、token filters（token过滤器）。<br>
一个analyzer可以有0个或多个character filters<br>
一个analyzer有且只能有一个tokenizer<br>
一个analyzer可以有0个或多个token filters<br>
character filter 是做字符转换的，它接收的是文本字符流，输出也是字符流<br>
tokenizer 是做分词的，它接收字符流，输出token流（文本拆分后变成一个一个单词，这些单词叫token）<br>
token filter 是做token过滤的，它接收token流，输出也是token流<br>
由此可见，整个analyzer要做的事情就是将文本拆分成单个单词，文本 ----&gt;  字符  ----&gt;  token<br>
分析器的任务是分析（Analyze）文本数据，分析是分词，规范化文本的意思</p>
<p>ES在创建索引时, 默认创建5个分片(shard), 每个分片有一份备份/复制分片(replica shard), 可以修改, 分片的数量只能在创建索引的时候指定, 索引创建后就不能修改分片的数量了, 而备份是可以动态修改的</p>
<p>反向索引又叫倒排索引，是根据文章内容中的关键字建立索引<br>
Keyword 类型是不会分词的，直接根据字符串内容建立反向索引，Text 类型在存入 Elasticsearch 的时候，会先分词（指定分词器会按指定分词器分词，未指定按默认分词器分词）），然后根据分词后的内容建立反向索引</p>
<p>java REST api是通过http访问，走9200端口（java api是9300端口）。<br>
虽然es带有java api，但是会引起版本兼容性的问题，以及微弱到可以忽略的性能提升，并且java api在未来的es版本会放弃，官方推荐使用java REST api</p>
<p>每个elasticsaerch分片都是一个Lucene 索引。在单个索引中你最多可以存储2147483519 (= Integer.MAX_VALUE - 128) 个文档。你可以使用 _cat/shards api去监控分片的的大小。<br>
<strong>Es配置文件</strong></p>
<pre><code class="language-java">vim elasticsearch.yml

#集群名字，es启动后会将具有相同集群名字的节点放到一个集群下。
cluster.name:  elasticsearch
#节点名字
node.name: &quot;es-node1&quot;
#指定集群中的节点中有几个有master资格的节点。
#对于大集群可以写3个以上。
discovery.zen.minimum_master_nodes: 2
#设置集群中自动发现其它节点时ping连接超时时间，默认是3s，
#为避免因为网络差而导致启动报错，设成了40s。
discovery.zen.ping.timeout: 40s
#设置是否打开多播发现节点，默认是true
discovery.zen.ping.multicast.enabled: false
#ip地址
network.host: 192.168.137.100
#指明集群中其它可能为master的节点ip,以防es启动后发现不了集群中的其他节点。
discovery.zen.ping.unicast.hosts:[&quot;节点1的 ip&quot;,&quot;节点2 的ip&quot;,&quot;节点3的ip&quot;]

一般测试时，只需要改一下cluster.name、node.name、network.host即可，使用默认也可以
</code></pre>
<p><strong>Es启动:</strong></p>
<pre><code class="language-java">启动:# bin/elasticsearch
发生以下错误:Caused by: java.lang.RuntimeException: can not run elasticsearch as root(不能用root用户启动)    原因:root用户权限过大
解决方案： useradd es (添加一个es用户)
		 passwd es (设置用户es密码)
		 chown -R es:es * (给es用户权限)

切换到上面新添加的es用户再次执行启动命令:此时可能会出现3个错误
ERROR: [3] bootstrap checks failed
[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at
least [65536]
	解决(切换到root用户)：
	vim /etc/security/limits.conf
	# 添加以下内容(*也是,代表所有用户):增大内存和硬盘
    * soft nofile 65536
    * hard nofile 131072
    * soft nproc 2048
    * hard nproc 4096
[2]:max number of threads [3802] for user [es] is too low, increase to at least [4096]
	解决:
	vim /etc/security/limits.d/90-nproc.conf(用户最大线程数)
	修改以下内容
	*	soft	nproc	4096(原先是1024)
[3]:max virtual memory areas vm.max_map_count [65530] is too low, increase to at least
[262144]	
	解决:
	vim /etc/sysctl.conf(配置最大线程数)
	# 添加以下内容
	vm.max_map_count=655360

再次切换到es用户执行启动命令成功启动
</code></pre>
<p><strong>Kibana工具</strong><br>
当es启动后，我们在命令行直接敲es命令是比较麻烦的，因此此时用到kibana插件，kibana是es的一个可视化视图工具，当然es也有其他的插件，比如<em><strong><strong>elasticsearch-head</strong></strong></em>，<em><strong><strong>ElasticHD</strong></strong></em>等等<br>
<strong>kibana的安装</strong><br>
kibana下载地址：<a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a>，注意：下载的版本要和es使用的版本要对应<br>
kibana的配置文件</p>
<pre><code class="language-java">vim  kibana.yml
#对外服务监听端口
server.port: 5601
#绑定可以访问5601端口服务的IP地址，0.0.0.0表示任何地址在没有防火墙限制的情况下都可以访问，生产环境别这样设置，不安全。
server.host: &quot;0.0.0.0&quot;
#默认值为主机名称，表示kibana实例绑定的主机，可以是IP地址或者主机名称.
server.name: &quot;192.168.1.11&quot;
#用来处理ES请求的服务URL
elasticsearch.hosts: [&quot;http://192.168.1.11:9200&quot;,&quot;http://192.168.1.12:9200&quot;]
#用来控制证书的认证，可选的值为full，none，certificate。此处由于没有证书，所以设置为null，否则启动会提示错误.
elasticsearch.ssl.verificationMode: none
#kibana搜索数据请求超时时间
elasticsearch.requestTimeout: 90000

更多配置信息查看：https://www.elastic.co/guide/en/kibana/5.6/settings.html

启动命令:kibana文件夹bin/kibana
</code></pre>
<p><strong>Es集群相关操作</strong></p>
<pre><code class="language-java">查看集群健康信息	GET /_cat/health?
	查看集群中节点信息	GET /_cat/nodes?v
	查看集群中的索引信息	GET /_cat/indices?v
	可以看到我们集群叫“elasticsearch”，运行状态是green。每当我们查询集群健康情况时，接口可能会返回green，yellow或red状态。green意味着一切良好（集群所有的功能都正常）。
yellow意味着所有的数据都是可用的，但是一些复制分片可能没有正确分发（集群的所有功能还是正常的）。red意味着因为某些原因导致有些数据不能使用。
注意，即使集群状态是red，它仍然可以运行一部分的功能。（例如，它依然可以从一些可用的分片处理搜索请求）但你应该尽快去修复它，因为这样会使搜索结果丢失一些数据
</code></pre>
<p><strong>索引相关操作</strong></p>
<pre><code class="language-java">简单操作:	创建:	put/索引名		删除:delete/索引名

put、get、post、delete操作
	添加数据
	put 索引名/类型名/文档(id)	{json数据}
		不指定类型(id)时,会随机生成id值,但只能用post post 索引名/类型名 {json数据}
	获取数据	get 索引名/类型名/文档(id)
	测试文档是否存在	
        HEAD 索引名/类型名/文档(id)		
        200 - OK	200:该文档存在		404 - Not Found		404:该文档不存在
	批量获取	主要是Get (索引名/类型名)_mget	{json数据}	具体分类看保存的图片
批处理操作
	POST /索引名/类型/_bulk # 批量插入多个document
    {&quot;index&quot;:{}}
    {&quot;name&quot;:&quot;ww&quot;,&quot;title&quot;:&quot;王五&quot;,&quot;age&quot;:18,&quot;created&quot;:&quot;2018-12-27&quot;}
    {&quot;index&quot;:{}}
    {&quot;name&quot;:&quot;zl&quot;,&quot;title&quot;:&quot;赵六&quot;,&quot;age&quot;:25,&quot;created&quot;:&quot;2018-12-27&quot;}
    POST /索引名/类型名/_bulk # 批量操作（包含修改和删除）
    {&quot;update&quot;:{&quot;_id&quot;:&quot;KrOP6WcBVEuCC3JS8V9K&quot;}} # 修改
    {&quot;doc&quot;:{&quot;title&quot;:&quot;王小五&quot;}}
    {&quot;delete&quot;:{&quot;_id&quot;:&quot;K7OP6WcBVEuCC3JS8V9K&quot;}} # 删除    
es更新文档的原理为：先找到这个文档，删除旧的文档内容执行更新，更新完后再索引最新的文档
	
过滤器	注意： 过滤查询运行时先执行过滤语句，后执行普通查询	
	过滤器的类型
	1. term 、 terms Filter
	term、terms的含义与查询时一致。term用于精确匹配、terms用于多词条匹配
	2. ranage filter	3. exists filter	4. ids filter
Query和Filter更详细的对比可参考：https://blog.csdn.net/laoyang360/article/details/80468757

Mapping Type：
1. 简单类型： text , keyword , date , long , double , boolean or ip
2. 其它类型： object , geo_point , geo_shape 等

查看类型mapping			GET /索引名/_mapping/类型名    GET 索引名/_mapping?pretty
查看某个字段的分词结果
GET your_index/your_type/your_id/_termvectors?fields=your_fieldsName
</code></pre>
<p><strong>IK分词器</strong><br>
elasticSearch默认的分词器对中文不是很友好，会将中文单个字的建立索引，因此可以使用ik分词器</p>
<pre><code class="language-java">ik分词器下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases
同样，版本尽量和Es相对应。
下载完以后在Es的plugins文件夹中创建一个名为IK的文件夹，将下载的ik分词器解压到该文件夹下，
重新启动Es,出现plugin [analysis-ik]说明ik分词器被加载。

Ik分词器的两种方式:
智能模式和细粒度模式（智能：对应es的IK插件的ik_smart，细粒度：对应es的IK插件的ik_max_word）
细粒度分词，包含每一种切分可能(更全)；而智能模式，只包含各种切分路径中最可能的一种。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Storm 运行jar出错:org.apache.storm.thrift.TApplicationException: getLeader failed: unknownre result]]></title>
        <id>https://mask0407.github.io/storm00/</id>
        <link href="https://mask0407.github.io/storm00/">
        </link>
        <updated>2020-06-29T02:58:00.000Z</updated>
        <content type="html"><![CDATA[<p>编写完storm的java代码准备在集群环境运行测试，结果报错：<br>
<img src="https://img-blog.csdnimg.cn/20190617202806767.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L00yODM1OTIzMzg=,size_16,color_FFFFFF,t_70" alt="错误信息" loading="lazy"><br>
起初以为是代码的错误，结果检查半天也没错误<br>
后来去UIServer看集群状态，发现有节点宕掉了。<br>
最后：重启机群，重新执行</p>
<pre><code class="language-shell">storm jar storm-lowlevel-1.0-SNAPSHOT.jar com.msk.demo01.WordCountTopolpgy
</code></pre>
<p>错误解决<br>
如果重启集群出错，先检查zookeeper集群状态，确保zookeeper集群可用</p>
]]></content>
    </entry>
</feed>