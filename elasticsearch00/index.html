<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Elasticsearch入门篇 | 个人博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css">
<link rel="shortcut icon" href="https://mask0407.github.io/favicon.ico?v=1593400024594">
<link rel="stylesheet" href="https://mask0407.github.io/styles/main.css">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="ElasticSearch
ElasticSearch:简称为ES，基于Lucene全文检索引擎服务，支持分布式集群（数据横向扩展、分布式计算）
应用场景：1. 全文检索或者搜索服务	2. NOSQL数据库(ES中的数据单元为JSON)	3..." />
    <meta name="keywords" content="Elasticsearch" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://mask0407.github.io">
        <img src="https://mask0407.github.io/images/avatar.png?v=1593400024594" class="site-logo">
        <h1 class="site-title">个人博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://mask0407.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Elasticsearch入门篇</h2>
            <div class="post-date">2020-06-29</div>
            
            <div class="post-content" v-pre>
              <h2 id="elasticsearch">ElasticSearch</h2>
<p>ElasticSearch:简称为ES，基于Lucene全文检索引擎服务，支持分布式集群（数据横向扩展、分布式计算）<br>
应用场景：1. 全文检索或者搜索服务	2. NOSQL数据库(ES中的数据单元为JSON)	3. ELK数据分析平台</p>
<p>NRT (near real time) 接近实时 ES中的一条数据写入后大概会有1s的延迟才能被检索到<br>
9300端口:Es节点之间通讯使用		9200:Es节点和外部通讯使用</p>
<p><strong>Es概念介绍</strong>:</p>
<table>
<thead>
<tr>
<th>名词</th>
<th>说明</th>
<th>额外补充</th>
</tr>
</thead>
<tbody>
<tr>
<td>索引(index)</td>
<td>类似于数据库中的database</td>
<td></td>
</tr>
<tr>
<td>类型(type)</td>
<td>相当于sql中的table</td>
<td>Es6.0以后删除了类型的概念,6.0还可以设置类型,但只能设置一个</td>
</tr>
<tr>
<td>文档(Document)</td>
<td>相当于sql中的一行记录</td>
<td></td>
</tr>
<tr>
<td>分片(Shard)</td>
<td>每个索引都有1到多个分片, 每个分片都是一个luncene索引</td>
<td>片的好处: 分摊索引的搜索压力, 分片还支持水平的拓展和拆分以及分布式的操作, 可以提高搜索和其他处理的效率</td>
</tr>
<tr>
<td>备份/复制(replicas)</td>
<td>拷贝一个分片就完成了分片的备份</td>
<td>备份的好处: 当主分片失败或者挂掉, 备份就可以代替分片进行操作, 进而提高了es的可用性, 备份的分片还可以进行搜索操作, 以分摊搜索的压力.</td>
</tr>
<tr>
<td>映射(Mapping)</td>
<td>类似于Table的Schema(模式)</td>
<td>例如:create table person_info(name varchar(20),age tinyint)创建一张表,person后的括号是定义表中的字段,即为Schema</td>
</tr>
</tbody>
</table>
<p><strong>analyzer（分析器）介绍</strong><br>
analyzer（分析器）是一个包，这个包由三部分组成，分别是：character filters （字符过滤器）、tokenizer（分词器）、token filters（token过滤器）。<br>
一个analyzer可以有0个或多个character filters<br>
一个analyzer有且只能有一个tokenizer<br>
一个analyzer可以有0个或多个token filters<br>
character filter 是做字符转换的，它接收的是文本字符流，输出也是字符流<br>
tokenizer 是做分词的，它接收字符流，输出token流（文本拆分后变成一个一个单词，这些单词叫token）<br>
token filter 是做token过滤的，它接收token流，输出也是token流<br>
由此可见，整个analyzer要做的事情就是将文本拆分成单个单词，文本 ----&gt;  字符  ----&gt;  token<br>
分析器的任务是分析（Analyze）文本数据，分析是分词，规范化文本的意思</p>
<p>ES在创建索引时, 默认创建5个分片(shard), 每个分片有一份备份/复制分片(replica shard), 可以修改, 分片的数量只能在创建索引的时候指定, 索引创建后就不能修改分片的数量了, 而备份是可以动态修改的</p>
<p>反向索引又叫倒排索引，是根据文章内容中的关键字建立索引<br>
Keyword 类型是不会分词的，直接根据字符串内容建立反向索引，Text 类型在存入 Elasticsearch 的时候，会先分词（指定分词器会按指定分词器分词，未指定按默认分词器分词）），然后根据分词后的内容建立反向索引</p>
<p>java REST api是通过http访问，走9200端口（java api是9300端口）。<br>
虽然es带有java api，但是会引起版本兼容性的问题，以及微弱到可以忽略的性能提升，并且java api在未来的es版本会放弃，官方推荐使用java REST api</p>
<p>每个elasticsaerch分片都是一个Lucene 索引。在单个索引中你最多可以存储2147483519 (= Integer.MAX_VALUE - 128) 个文档。你可以使用 _cat/shards api去监控分片的的大小。<br>
<strong>Es配置文件</strong></p>
<pre><code class="language-java">vim elasticsearch.yml

#集群名字，es启动后会将具有相同集群名字的节点放到一个集群下。
cluster.name:  elasticsearch
#节点名字
node.name: &quot;es-node1&quot;
#指定集群中的节点中有几个有master资格的节点。
#对于大集群可以写3个以上。
discovery.zen.minimum_master_nodes: 2
#设置集群中自动发现其它节点时ping连接超时时间，默认是3s，
#为避免因为网络差而导致启动报错，设成了40s。
discovery.zen.ping.timeout: 40s
#设置是否打开多播发现节点，默认是true
discovery.zen.ping.multicast.enabled: false
#ip地址
network.host: 192.168.137.100
#指明集群中其它可能为master的节点ip,以防es启动后发现不了集群中的其他节点。
discovery.zen.ping.unicast.hosts:[&quot;节点1的 ip&quot;,&quot;节点2 的ip&quot;,&quot;节点3的ip&quot;]

一般测试时，只需要改一下cluster.name、node.name、network.host即可，使用默认也可以
</code></pre>
<p><strong>Es启动:</strong></p>
<pre><code class="language-java">启动:# bin/elasticsearch
发生以下错误:Caused by: java.lang.RuntimeException: can not run elasticsearch as root(不能用root用户启动)    原因:root用户权限过大
解决方案： useradd es (添加一个es用户)
		 passwd es (设置用户es密码)
		 chown -R es:es * (给es用户权限)

切换到上面新添加的es用户再次执行启动命令:此时可能会出现3个错误
ERROR: [3] bootstrap checks failed
[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at
least [65536]
	解决(切换到root用户)：
	vim /etc/security/limits.conf
	# 添加以下内容(*也是,代表所有用户):增大内存和硬盘
    * soft nofile 65536
    * hard nofile 131072
    * soft nproc 2048
    * hard nproc 4096
[2]:max number of threads [3802] for user [es] is too low, increase to at least [4096]
	解决:
	vim /etc/security/limits.d/90-nproc.conf(用户最大线程数)
	修改以下内容
	*	soft	nproc	4096(原先是1024)
[3]:max virtual memory areas vm.max_map_count [65530] is too low, increase to at least
[262144]	
	解决:
	vim /etc/sysctl.conf(配置最大线程数)
	# 添加以下内容
	vm.max_map_count=655360

再次切换到es用户执行启动命令成功启动
</code></pre>
<p><strong>Kibana工具</strong><br>
当es启动后，我们在命令行直接敲es命令是比较麻烦的，因此此时用到kibana插件，kibana是es的一个可视化视图工具，当然es也有其他的插件，比如<em><strong><strong>elasticsearch-head</strong></strong></em>，<em><strong><strong>ElasticHD</strong></strong></em>等等<br>
<strong>kibana的安装</strong><br>
kibana下载地址：<a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a>，注意：下载的版本要和es使用的版本要对应<br>
kibana的配置文件</p>
<pre><code class="language-java">vim  kibana.yml
#对外服务监听端口
server.port: 5601
#绑定可以访问5601端口服务的IP地址，0.0.0.0表示任何地址在没有防火墙限制的情况下都可以访问，生产环境别这样设置，不安全。
server.host: &quot;0.0.0.0&quot;
#默认值为主机名称，表示kibana实例绑定的主机，可以是IP地址或者主机名称.
server.name: &quot;192.168.1.11&quot;
#用来处理ES请求的服务URL
elasticsearch.hosts: [&quot;http://192.168.1.11:9200&quot;,&quot;http://192.168.1.12:9200&quot;]
#用来控制证书的认证，可选的值为full，none，certificate。此处由于没有证书，所以设置为null，否则启动会提示错误.
elasticsearch.ssl.verificationMode: none
#kibana搜索数据请求超时时间
elasticsearch.requestTimeout: 90000

更多配置信息查看：https://www.elastic.co/guide/en/kibana/5.6/settings.html

启动命令:kibana文件夹bin/kibana
</code></pre>
<p><strong>Es集群相关操作</strong></p>
<pre><code class="language-java">查看集群健康信息	GET /_cat/health?
	查看集群中节点信息	GET /_cat/nodes?v
	查看集群中的索引信息	GET /_cat/indices?v
	可以看到我们集群叫“elasticsearch”，运行状态是green。每当我们查询集群健康情况时，接口可能会返回green，yellow或red状态。green意味着一切良好（集群所有的功能都正常）。
yellow意味着所有的数据都是可用的，但是一些复制分片可能没有正确分发（集群的所有功能还是正常的）。red意味着因为某些原因导致有些数据不能使用。
注意，即使集群状态是red，它仍然可以运行一部分的功能。（例如，它依然可以从一些可用的分片处理搜索请求）但你应该尽快去修复它，因为这样会使搜索结果丢失一些数据
</code></pre>
<p><strong>索引相关操作</strong></p>
<pre><code class="language-java">简单操作:	创建:	put/索引名		删除:delete/索引名

put、get、post、delete操作
	添加数据
	put 索引名/类型名/文档(id)	{json数据}
		不指定类型(id)时,会随机生成id值,但只能用post post 索引名/类型名 {json数据}
	获取数据	get 索引名/类型名/文档(id)
	测试文档是否存在	
        HEAD 索引名/类型名/文档(id)		
        200 - OK	200:该文档存在		404 - Not Found		404:该文档不存在
	批量获取	主要是Get (索引名/类型名)_mget	{json数据}	具体分类看保存的图片
批处理操作
	POST /索引名/类型/_bulk # 批量插入多个document
    {&quot;index&quot;:{}}
    {&quot;name&quot;:&quot;ww&quot;,&quot;title&quot;:&quot;王五&quot;,&quot;age&quot;:18,&quot;created&quot;:&quot;2018-12-27&quot;}
    {&quot;index&quot;:{}}
    {&quot;name&quot;:&quot;zl&quot;,&quot;title&quot;:&quot;赵六&quot;,&quot;age&quot;:25,&quot;created&quot;:&quot;2018-12-27&quot;}
    POST /索引名/类型名/_bulk # 批量操作（包含修改和删除）
    {&quot;update&quot;:{&quot;_id&quot;:&quot;KrOP6WcBVEuCC3JS8V9K&quot;}} # 修改
    {&quot;doc&quot;:{&quot;title&quot;:&quot;王小五&quot;}}
    {&quot;delete&quot;:{&quot;_id&quot;:&quot;K7OP6WcBVEuCC3JS8V9K&quot;}} # 删除    
es更新文档的原理为：先找到这个文档，删除旧的文档内容执行更新，更新完后再索引最新的文档
	
过滤器	注意： 过滤查询运行时先执行过滤语句，后执行普通查询	
	过滤器的类型
	1. term 、 terms Filter
	term、terms的含义与查询时一致。term用于精确匹配、terms用于多词条匹配
	2. ranage filter	3. exists filter	4. ids filter
Query和Filter更详细的对比可参考：https://blog.csdn.net/laoyang360/article/details/80468757

Mapping Type：
1. 简单类型： text , keyword , date , long , double , boolean or ip
2. 其它类型： object , geo_point , geo_shape 等

查看类型mapping			GET /索引名/_mapping/类型名    GET 索引名/_mapping?pretty
查看某个字段的分词结果
GET your_index/your_type/your_id/_termvectors?fields=your_fieldsName
</code></pre>
<p><strong>IK分词器</strong><br>
elasticSearch默认的分词器对中文不是很友好，会将中文单个字的建立索引，因此可以使用ik分词器</p>
<pre><code class="language-java">ik分词器下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases
同样，版本尽量和Es相对应。
下载完以后在Es的plugins文件夹中创建一个名为IK的文件夹，将下载的ik分词器解压到该文件夹下，
重新启动Es,出现plugin [analysis-ik]说明ik分词器被加载。

Ik分词器的两种方式:
智能模式和细粒度模式（智能：对应es的IK插件的ik_smart，细粒度：对应es的IK插件的ik_max_word）
细粒度分词，包含每一种切分可能(更全)；而智能模式，只包含各种切分路径中最可能的一种。</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://mask0407.github.io/F5ekRJs32/" class="tag">
                    Elasticsearch
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://mask0407.github.io/storm00/">
                  <h3 class="post-title">
                    Storm 运行jar出错:org.apache.storm.thrift.TApplicationException: getLeader failed: unknownre result
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.min.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
